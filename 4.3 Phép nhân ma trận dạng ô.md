# Mục tiêu
- Để hiểu thiết kế của thuật toán song song theo dạng ô cho phép nhân ma trận
	- Hiểu cách tải một ô dữ liệu ([[tiling]]).
	- Hiểu quá trình thực thi theo [[pha]].
	- Hiểu cơ chế [[đồng bộ rào cản]].
# Phép nhân ma trận
- Mô hình truy cập dữ liệu
	- Mỗi [[luồng]] xử lý một hàng của ma trận M và một cột của ma trận N.
	- Mỗi [[khối luồng]] xử lý một dải của ma trận M và một dải của ma trận N.
- Đây là một đánh giá khái niệm về quá trình thực thi phép nhân ma trận. Nếu chúng ta quan sát mô hình truy cập dữ liệu của các luồng, thì mỗi luồng tạo ra một phần tử \( P \) sẽ cần truy cập một hàng của ma trận \( M \) và một cột của ma trận \( N \), được minh họa bằng dải hẹp trong \( M \) và \( N \).  

- Nếu chúng ta xem xét yêu cầu dữ liệu cho toàn bộ một block luồng, thì ta sẽ thấy rằng block đó cần truy cập một dải của \( M \) và một dải của \( N \), trong đó mỗi dải có độ rộng bằng `block_width`.
![[Pasted image 20250219134255.png]]
# Phép nhân ma trận dạng [[ô]]
- Chia nhỏ quá trình thực thi của mỗi luồng thành các [[pha]].
- Trong mỗi [[pha]], [[luồng]] chỉ truy cập một ô của ma trận M và một ô của ma trận N.
- Mỗi ô có kích thước là BLOCK_SIZE x BLOCK_SIZE.

![[Pasted image 20250219134957.png]]
-  Ý tưởng cơ bản của phép nhân ma trận theo khối (tile matrix multiplication) là chia quá trình thực thi của mỗi luồng thành các giai đoạn sao cho dữ liệu được truy cập bởi block luồng trong mỗi giai đoạn tập trung vào một khối của ma trận M và một khối của ma trận N.  

-  Trong hình minh họa, ở giai đoạn đầu tiên, block luồng sẽ tập trung vào khối ngoài cùng bên trái của M và khối trên cùng của N.  

- Ở giai đoạn thứ hai, block luồng sẽ tập trung vào khối thứ hai từ bên trái của M và khối thứ hai từ trên xuống của N. Quá trình này sẽ lặp lại cho đến khi các khối bao phủ toàn bộ dải của M và toàn bộ dải của N cần thiết để tạo ra một khối các phần tử của P.  

- Chúng ta có thể thấy trong hình minh họa rằng các khối có kích thước bằng `block_size` theo mỗi chiều.
# Tải một [[ô]] dữ liệu (Loading a Tile)
- Tất cả các [[luồng]] trong một khối đều tham gia vào quá trình tải dữ liệu
	-   Mỗi luồng tải một phần tử từ ma trận M và một phần tử  từ ma trận N vào [[bộ nhớ chia sẻ]]. 
- 
- 
- Trong vài slide tiếp theo, chúng ta sẽ nghiên cứu chi tiết về cách hoạt động của thuật toán nhân ma trận theo khối (tiled matrix multiplication).

- Ở đầu mỗi giai đoạn, chúng ta cần nạp một khối của MM và một khối của NN. Để làm điều này, tất cả các luồng trong một block sẽ phải phối hợp với nhau.

- Hãy nhớ rằng số phần tử trong mỗi khối NN bằng với số luồng trong block luồng. Vì vậy, trong thuật toán nhân ma trận theo khối, chúng ta có thể để mỗi luồng nạp một phần tử của MM và một phần tử của NN.
# Pha 0 - Tải dữ liệu cho khối (0,0)
- Dữ liệu từ M và N được nạp vào [[bộ nhớ chia sẻ]].
- Mỗi [[luồng]] chịu trách nhiệm tải một phần tử.
![[Pasted image 20250219140622.png]]
- Chúng ta sẽ sử dụng ví dụ ma trận 4x4 để minh họa cách tải các ô (tiles) trong thuật toán nhân ma trận theo pha (phased matrix multiplication algorithm).

- Chúng ta chọn khối 00 làm ví dụ tiêu biểu. Khối 00 sẽ có bốn luồng thực hiện tính toán để tạo ra các phần tử P00,P01,P10,P11P_{00}, P_{01}, P_{10}, P_{11}, tức là ô vuông nhỏ ở góc trên bên trái của ma trận kết quả PP.

- Ở pha đầu tiên, pha 0, quá trình tính toán này sẽ liên quan đến ô vuông nhỏ ở góc trên bên trái của ma trận MM và ô vuông nhỏ tương ứng ở góc trên bên trái của ma trận NN. Thuật toán chia ô (tiled algorithm) sẽ cho phép tất cả các luồng trong khối hợp tác với nhau để tải ô vuông nhỏ đó từ MM và NN vào bộ nhớ chia sẻ.

- Vì số phần tử cần tải vào bộ nhớ chia sẻ bằng với số luồng trong khối luồng, chúng ta có thể sử dụng một luồng để tải từng phần tử của MM và một luồng để tải từng phần tử của NN. Điều này được minh họa bằng các mũi tên màu đỏ, biểu thị quá trình tải dữ liệu từ bộ nhớ toàn cục (global memory) vào bộ nhớ chia sẻ (shared memory).
# Pha 0 - Sử dụng dữ liệu trong khối (0,0) (lặp lại 0)
- Dữ liệu đã được tải vào [[bộ nhớ chia sẻ]] được sử dụng để tính toán kết quả.
- Các phần tử từ M và N được kết hợp để tạo ra một phần của ma trận kết quả P.
![[Pasted image 20250219140645.png]]
- Khi các ô (tiles) đã được tải vào bộ nhớ chia sẻ, chúng ta có thể thực hiện pha 0 bằng cách lấy các toán hạng đầu vào từ bộ nhớ chia sẻ thay vì bộ nhớ toàn cục.

- Bây giờ, chúng ta xem xét quá trình thực thi của vòng lặp tích vô hướng (inner product) tại bước lặp 0. Tất cả các luồng sẽ lấy một phần tử từ M và một phần tử từ N.

- Đối với \(P_{00}\​), luồng 00 sẽ lấy M00M_{00}M00​ và N00N_{00}N00​ từ bộ nhớ chia sẻ. Tương tự, đối với luồng 11, luồng này sẽ lấy M11M_{11}M11​ và N11N_{11}N11​ từ bộ nhớ chia sẻ để thực hiện một bước lặp của phép nhân vô hướng.
# Pha 0 - Sử dụng dữ liệu trong khối (0,0) (lặp lại 1)
- Tiếp tục quá trình tính toán bằng cách sử dụng dữ liệu đã tải.
![[Pasted image 20250219140700.png]]
# Pha 1 - Tải dữ liệu cho khối (0,0)
- Một tập hợp dữ liệu mới từ M và N được nạp vào [[bộ nhớ chia sẻ]].
- Các [[luồng]] thực hiện lại quá trình tải dữ liệu.
![[Pasted image 20250219140819.png]]
# Pha 1 - Sử dụng dữ liệu trong khối (0,0) (lặp lại 0)
- Tiếp tục sử dụng dữ liệu từ [[bộ nhớ chia sẻ]] để thực hiện phép nhân ma trận.
![[Pasted image 20250219140859.png]]
# Pha 1 - Sử dụng dữ liệu trong khối (0,0) (lặp lại 1)
- Hoàn tất việc tính toán kết quả của phần ma trận P tương ứng với khối này.
![[Pasted image 20250219140946.png]]
# Các pha thực thi của ví dụ minh họa
![[Pasted image 20250219142259.png]]
![[Pasted image 20250219142323.png]]
- [[Bộ nhớ chia sẻ]] cho phép nhiều [[luồng]] truy cập cùng một giá trị dữ liệu, tối ưu hóa hiệu suất.
# Đồng bộ hóa rào cản (Barrier Synchronization)
- Đồng bộ hóa tất cả các luồng trong một khối
	- __ syncthreads()
- Lệnh __ syncthreads() đảm bảo tất cả các luồng trong cùng một khối phải hoàn thành một [[pha]] trước khi tiếp tục.
- Được sử dụng để điều phối thuật toán dạng [[ô]], giúp:
	- Đảm bảo rằng tất cả các phần tử của một ô dữ liệu được tải vào trước khi sử dụng.
	- Đảm bảo rằng tất cả các phần tử của một ô dữ liệu đã được sử dụng trước khi tiếp tục [[pha]] tiếp theo.
	