## Mục tiêu
- Học cách sử dụng hiệu quả các loại bộ nhớ [[CUDA]] trong chương trình song song.
- Phân tích tầm quan trọng của hiệu quả truy cập bộ nhớ và phân tích cách thức thông lượng truy cập bộ nhớ có thể là một yếu tố giới hạn thông lượng thực thi của một bộ xử lý song song lớn. 
- Xem xét các thanh ghi (Register), bộ nhớ chia sẻ (shared memory) và bộ nhớ toàn cục (global memory) với trọng tâm vào phạm vi và thời gian tồn tại của các biến được khai báo trong các loại bộ nhớ này. 
## Kernel làm mờ hình ảnh - Image Blur Kernel trong lập trình CUDA
   
![[Ảnh màn hình 2025-03-13 lúc 20.15.01.png]]

Bên trên là đoạn code dùng trong CUDA để làm mờ một hình ảnh bằng cách tính trung bình các pixel xung quanh một điểm ảnh cụ thể. 
- Mục đích: Làm mờ một ảnh bằng cách thay thế mỗi pixel bằng trung bình của các pixel xung quanh trong một vùng có kích thước (2×BLUR_SIZE+1)×(2×BLUR_SIZE+1) 
- Cách hoạt động: 
1. Duyệt qua vùng xung quanh: 
   Hai vòng lặp `for` quét qua vùng lân cận có kích thước (2×BLUR_SIZE+1)×(2×BLUR_SIZE+1)(2×BLUR_SIZE+1)×(2×BLUR_SIZE+1) quanh mỗi pixel trung tâm.
2. Tính toán vị trí mới: 
   `curRow` và `curCol` là tọa độ của các pixel lân cận.
3. Kiểm tra hợp lệ: 
   Điều kiện `if` đảm bảo chỉ lấy giá trị của những pixel nằm trong biên ảnh (tránh truy cập ngoài vùng nhớ).
4. Tính tổng giá trị pixel: 
   Nếu pixel hợp lệ, cộng giá trị vào `pixVal` và tăng biến đếm `pixels`.
5. Gán giá trị pixel mới: 
   Sau khi duyệt qua tất cả các pixel lân cận, lấy giá trị trung bình và gán vào ảnh kết quả
## Vấn đề hiệu năng trên GPU ? 
1. Vấn đề truy cập bộ nhớ toàn cục (Global Memory)
   - Mỗi thread truy cập vào bộ nhớ toàn cục để lấy dữ liệu của ma trận đầu vào. 
   - Mỗi phép cộng số thực dấu phẩy động (floating-point addition) cần một lần truy cập bộ nhớ, và mỗi lần truy cập tốn 4 byte dữ liệu.
   - Tỷ lệ băng thông bộ nhớ trên FLOPS (4B/s trên FLOP) ảnh hưởng đến hiệu năng thực thi. 
2. Giả sử GPU có các thông số sau: 
   - **Tốc độ tính toán tối đa**: 1600 GFLOPS (tức là 1600 tỷ phép tính dấu chấm động mỗi giây).
   - **Băng thông bộ nhớ DRAM**: 600 GB/s.
   - Để đạt được **FLOPS tối đa**, GPU cần đọc dữ liệu với tốc độ:  4×1,600=6,400 GB/s nhưng băng thông thực tế chỉ có **600 GB/s**.
   - Do giới hạn băng thông, GPU chỉ có thể thực thi ở **150 GFLOPS**.
   ==> Tỷ lệ hiệu năng thực tế so với lý thuyết: 150 / 1600 = 9.3%
   ==> GPU chỉ hoạt động với **9.3% công suất tối đa** do bị giới hạn bởi băng thông bộ nhớ.
   ==> Cần giảm đáng kể số lần truy cập bộ nhớ để tiến gần đến mức 1600 GFLOPS
3. Kết luận: 
   - GPU có tốc độ tính toán rất cao, nhưng nếu **truy cập bộ nhớ không hiệu quả**, hiệu năng thực tế bị giảm mạnh.
   - Để cải thiện hiệu suất, cần **tối ưu việc truy cập bộ nhớ** để giảm thiểu tắc nghẽn băng thông.
## Ví dụ: Phép nhân ma trận

![[Ảnh màn hình 2025-03-14 lúc 00.16.37.png]]

- Hình trên là một ví dụ cơ bản - phép nhân ma trận để minh hoạ việc sủ dụng hiệu quả các loại bộ nhớ. Sơ đồ cho thấy cách chia ma trận thành các khối với BLOCK_WIDTH và thực hiện tính toán song song. Trong đó: 
	  - M, N: hai ma trận đầu vào.
	  - P: Kết quả phép nhân ma trận P = M x N
- Để tính toán ma trận đầu ra P, mỗi phần tử của ma trận đầu ra P là tích vô hướng của một hàng của M, như hình minh hoạ đang hiển thị theo hướng ngang của mũi tên, và một cột của N, như hình minh hoạ đang hiển thị trong dải dọc và mũi tên dọc trong slide này.
## Kernel nhân ma trận

![[Ảnh màn hình 2025-03-14 lúc 01.14.05.png]]

- Hình trên là một kernel nhân ma trận cơ bản. Vì chúng ta đang tạo ra một mảng đầu ra P hai chiều, chúng ta có thể chỉ cần một luồng để tạo ra một phần tử của mảng đầu ra P. Điều này tương tự như kernel làm mờ hình ảnh (Image Blur Kernel).
- Trong đoạn mã này, chúng ta tính toán chỉ số hàng và chỉ số cột cho phần tử P mà một luồng cụ thể chịu trách nhiệm bằng cách sử dụng các giá trị `blockIdx`, `blockDim`, và `threadIdx`. Chỉ số hàng `Row` được tính bằng `blockIdx.y * blockDim.y + threadIdx.y`, và chỉ số cột `Col` được tính bằng `blockIdx.x * blockDim.x + threadIdx.x`.
- Mỗi luồng sẽ tính toán một phần tử của P bằng cách thực hiện một tích vô hướng giữa một hàng của M và một cột của N. Vòng lặp `for` thực hiện phép nhân từng phần tử tương ứng của hàng `Row` trong M và cột `Col` trong N, sau đó cộng dồn vào `Pvalue`. Cuối cùng, giá trị này được lưu vào phần tử `P[Row * Width + Col]`.