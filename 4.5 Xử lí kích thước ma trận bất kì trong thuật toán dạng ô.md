[[4.4 Phép nhân ma trận dạng ô nhớ kernel|Phép nhân ma trận dạng ô kernel]] trình bày trong 4.4 chỉ có thể xử lí ma trận có kích thước là bội số của chiều rộng [[ô]] 
# Mục tiêu
Để xử lí ma trận có kích thước bất kì trong phép nhân ma trận dạng ô
- Kiểm tra [[điều kiện biên]] khi [[tải ô|tải các ô]]
- Điều chỉnh nội dung của [[ô]] để đơn giản hóa phép tính lõi
- Mở rộng kĩ thuật để xử lí ma trận hình chữ nhật

# Vấn đề của với ma trận có kích thước không chia hết chiều rộng ô 
## Ví dụ 3 x 3


![[4.5.1.1.png]]
<p style="text-align:center;">Hình 4.5.1.1: Pha 1 tải cho khối (0, 0)</p>

Các ma trận có kích thước 3 x 3, không phải là bội số của chiều rộng ô (2)
Ô mặt 0 hoàn toàn nằm trong phạm vi hợp lệ của cả M và N

Khi chuyển sang pha 1, luồng (0, 1) và luồng (1, 1) sẽ cố gắng tải các phần tử M không hợp lệ. Tương tự, luồng (1, 0) và luồng (1, 1) sẽ cố gắng truy cập các phần tử N không hợp lệ.

Việc truy cập các phần tử không tồn tại có vấn đề theo hai cách. 
- **Việc truy cập một phần tử không tồn tại vượt quá cuối hàng** (truy cập M bởi luồng (0, 1) và luồng (1,1) trong Hình 4.5.1) sẽ được thực hiện đến các phần tử không chính xác. Trong ví dụ của chúng ta, các luồng sẽ cố gắng truy cập M0,3 và M1,3, cả hai đều không tồn tại. Trong trường hợp này, điều gì sẽ xảy ra với các tải bộ nhớ này? Để trả lời câu hỏi này, chúng ta cần quay lại bố cục tuyến tính hóa của ma trận 2D. Phần tử sau M0,2 trong bố cục tuyến tính hóa là M1,0. Mặc dù luồng (0,1) và luồng (1, 1) đang cố gắng truy cập M0,3 và M1,3, nó sẽ thay vào đó lấy M1,0 và M2,0. Việc sử dụng giá trị này trong tính toán tích vô hướng tiếp theo chắc chắn sẽ làm hỏng giá trị đầu ra ở P. 
- **Một vấn đề tương tự phát sinh khi truy cập một phần tử vượt quá cuối cột** (truy cập N bởi luồng (1,0) và luồng (1,1) trong Hình 4.5.1). Và điều này hơi khác so với trường hợp M vì các phần tử N không tồn tại đó sẽ hoàn toàn nằm ngoài phạm vi hợp lệ của dữ liệu N. Các truy cập này là đến các vị trí bộ nhớ bên ngoài vùng được cấp phát cho mảng nên trên hầu hết các [[phần cứng]], điều này có thể gây ra [[vi phạm truy cập bộ nhớ]]. Một số hệ thống sẽ trả về các giá trị ngẫu nhiên từ các cấu trúc dữ liệu khác, trong khi những hệ thống khác sẽ từ chối các truy cập này và khiến chương trình bị hủy. Dù bằng cách nào, các truy cập như vậy đều dẫn đến kết quả không mong muốn ở P.

---
![[4.5.1.2.png]]
<p style="text-align:center;">Hình 4.5.1.2: Pha 1 sử dụng cho khối (0, 0) (vòng lặp 0)</p>
Sau khi [[tải ô]] vào [[bộ nhớ chia sẻ]], [[pha]] 1 của [[khối luồng|khối]] (0, 0) sẽ sử dụng các phần tử M và N từ [[bộ nhớ chia sẻ]]. Đối với vòng lặp 0, các [[luồng]] sẽ tiêu thụ các phần tử M và N hợp lệ từ [[bộ nhớ chia sẻ]]. 

---

![[4.5.1.3.png]]
<p style="text-align:center;">Hình 4.5.1.3: Pha 1 sử dụng cho khối (0, 0) (vòng lặp 1)</p>

Khi chuyển sang vòng lặp 1, tất cả các luồng sẽ cố gắng tiêu thụ các phần tử không tồn tại trong bộ nhớ chia sẻ cho cả M và N trong trường hợp này. 
Vì vậy, chúng ta cần đảm bảo rằng không luồng nào trong số này sẽ làm ô nhiễm giá trị tích vô hướng của chúng bằng các giá trị không tồn tại này.

---
Ví dụ trước dường như gợi ý rằng điều kiện biên của việc tải các phần tử ma trận không tồn tại chỉ xảy ra trong pha 1 trong ví dụ hoặc trong pha cuối cùng của thuật toán dạng ô nói chung. Thật không may, các truy cập có vấn đề có thể xảy ra trong tất cả các pha.


![[4.5.1.4.png]]
<p style="text-align:center;">Hình 4.5.1.4: Pha 0 tải cho khối (1, 1) </p>

Từ hình 4.5.1.4, chúng ta thấy rằng luồng (1,0) và luồng (1,1) cố gắng truy cập các phần tử M không tồn tại M3,0 và M3,1, trong khi luồng (0,1) và luồng (1,1) cố gắng truy cập N0,3 và N1,3, không tồn tại.

Điều này gợi ý rằng việc kiểm tra điều kiện biên cần xảy ra trong mọi pha của thuật toán dạng ô. Chỉ là các luồng khác nhau trong các khối luồng khác nhau có thể gặp tình huống điều kiện biên trong các pha này.

---
## Tóm tắt 2 trường hợp chính

- **Trường hợp đầu tiên**: các luồng không tính toán các phần tử P hợp lệ, chúng vẫn cần tham gia tải các phần tử gạch đầu vào hợp lệ. 
	- Ví dụ, trong pha 0 của khối (1, 1), luồng (1, 0) được cho là tính toán P3,2 không tồn tại, vì vậy nó không tính toán bất kỳ phần tử P hợp lệ nào, nhưng nó vẫn cần tham gia tải phần tử gạch đầu vào N1,2.
- **Trường hợp thứ hai**: các luồng tính toán các phần tử P hợp lệ có thể cố gắng tải các phần tử gạch đầu vào không tồn tại khi tải gạch đầu vào. 
	- Ví dụ, trong pha 0 của khối (0, 0), luồng (1, 0), được gán để tính toán P10 hợp lệ, có thể cố gắng tải N3, 0 không tồn tại.

Điều này thực sự gợi ý rằng chúng ta cần có khả năng kiểm tra các điều kiện khác nhau cho mỗi luồng khi tải các phần tử ô so với khi thực hiện tính toán tích vô hướng và ghi vào phần tử đầu ra.
# Một giải pháp "đơn giản"

Khi luồng tải bất kỳ phần tử đầu vào nào, chúng ta sẽ kiểm tra xem nó có nằm trong phạm vi đầu vào hợp lệ hay không.

Nếu chỉ số được sử dụng nằm trong phạm vi đầu vào hợp lệ, thì chúng ta sẽ tiến hành tải phần tử này. Nếu không, chúng ta không thực hiện bất kỳ tải nào, mà chỉ ghi số 0 vào bộ nhớ chia sẻ.

Lý do là vì đối với phép nhân ma trận và tính toán tích vô hướng nói riêng, giá trị 0 sẽ đảm bảo rằng bước nhân-cộng không ảnh hưởng đến giá trị cuối cùng của phần tử đầu ra.

Rõ ràng, đây là một phương pháp tiếp cận dành riêng cho ứng dụng. Mỗi ứng dụng khác nhau có thể yêu cầu một giá trị mặc định khác nhau cho các phần tử gạch lẽ ra đã được tải từ các phần tử đầu vào không hợp lệ.

Sau đó, điều kiện mà chúng ta sẽ kiểm tra để tải các phần tử đầu vào khác với kiểm tra để tính toán phần tử P đầu ra. Vì vậy, khi chúng ta thực hiện tích vô hướng và ghi vào mảng đầu ra, chúng ta vẫn sẽ đảm bảo rằng một luồng không tính toán phần tử P đầu ra sẽ không thể ghi.



# Ví dụ và triển khai

# Tóm tắt các quan sát

# Mở rộng cho ma trận hình chữ nhật

# Kết luận