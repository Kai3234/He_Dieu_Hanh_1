[[4.4 Phép nhân ma trận dạng ô nhớ kernel|Phép nhân ma trận dạng ô kernel]] trình bày trong 4.4 chỉ có thể xử lí ma trận có kích thước là bội số của chiều rộng [[ô]] 
# Mục tiêu
Để xử lí ma trận có kích thước bất kì trong phép nhân ma trận dạng ô
- Kiểm tra [[điều kiện biên]] khi [[tải ô|tải các ô]]
- Điều chỉnh nội dung của [[ô]] để đơn giản hóa phép tính lõi
- Mở rộng kĩ thuật để xử lí ma trận hình chữ nhật

# Vấn đề của với ma trận có kích thước không chia hết chiều rộng ô 
## Ví dụ 3 x 3


![[4.5.1.1.png]]
<p style="text-align:center;">Hình 4.5.1.1: Pha 1 tải cho khối (0, 0)</p>

Các ma trận có kích thước 3 x 3, không phải là bội số của chiều rộng ô (2)
Ô mặt 0 hoàn toàn nằm trong phạm vi hợp lệ của cả M và N

Khi chuyển sang pha 1, luồng (0, 1) và luồng (1, 1) sẽ cố gắng tải các phần tử M không hợp lệ. Tương tự, luồng (1, 0) và luồng (1, 1) sẽ cố gắng truy cập các phần tử N không hợp lệ.

Việc truy cập các phần tử không tồn tại có vấn đề theo hai cách. 
- **Việc truy cập một phần tử không tồn tại vượt quá cuối hàng** (truy cập M bởi luồng (0, 1) và luồng (1,1) trong Hình 4.5.1) sẽ được thực hiện đến các phần tử không chính xác. Trong ví dụ của chúng ta, các luồng sẽ cố gắng truy cập M0,3 và M1,3, cả hai đều không tồn tại. Trong trường hợp này, điều gì sẽ xảy ra với các tải bộ nhớ này? Để trả lời câu hỏi này, chúng ta cần quay lại bố cục tuyến tính hóa của ma trận 2D. Phần tử sau M0,2 trong bố cục tuyến tính hóa là M1,0. Mặc dù luồng (0,1) và luồng (1, 1) đang cố gắng truy cập M0,3 và M1,3, nó sẽ thay vào đó lấy M1,0 và M2,0. Việc sử dụng giá trị này trong tính toán tích vô hướng tiếp theo chắc chắn sẽ làm hỏng giá trị đầu ra ở P. 

- **Một vấn đề tương tự phát sinh khi truy cập một phần tử vượt quá cuối cột** (truy cập N bởi luồng (1,0) và luồng (1,1) trong Hình 4.5.1). Và điều này hơi khác so với trường hợp M vì các phần tử N không tồn tại đó sẽ hoàn toàn nằm ngoài phạm vi hợp lệ của dữ liệu N. Các truy cập này là đến các vị trí bộ nhớ bên ngoài vùng được cấp phát cho mảng nên trên hầu hết các [[phần cứng]], điều này có thể gây ra [[vi phạm truy cập bộ nhớ]]. Một số hệ thống sẽ trả về các giá trị ngẫu nhiên từ các cấu trúc dữ liệu khác, trong khi những hệ thống khác sẽ từ chối các truy cập này và khiến chương trình bị hủy. Dù bằng cách nào, các truy cập như vậy đều dẫn đến kết quả không mong muốn ở P.

---
![[4.5.1.2.png]]
<p style="text-align:center;">Hình 4.5.1.2: Pha 1 sử dụng cho khối (0, 0) (vòng lặp 0)</p>
Sau khi [[tải ô]] vào [[bộ nhớ chia sẻ]], [[pha]] 1 của [[khối luồng|khối]] (0, 0) sẽ sử dụng các phần tử M và N từ [[bộ nhớ chia sẻ]]. Đối với vòng lặp 0, các [[luồng]] sẽ tiêu thụ các phần tử M và N hợp lệ từ [[bộ nhớ chia sẻ]]. 

---

![[4.5.1.3.png]]
<p style="text-align:center;">Hình 4.5.1.3: Pha 1 sử dụng cho khối (0, 0) (vòng lặp 1)</p>

Khi chuyển sang vòng lặp 1, tất cả các luồng sẽ cố gắng tiêu thụ các phần tử không tồn tại trong bộ nhớ chia sẻ cho cả M và N trong trường hợp này. 
Vì vậy, chúng ta cần đảm bảo rằng không luồng nào trong số này sẽ làm ô nhiễm giá trị tích vô hướng của chúng bằng các giá trị không tồn tại này.

---
Ví dụ trước dường như gợi ý rằng điều kiện biên của việc tải các phần tử ma trận không tồn tại chỉ xảy ra trong pha 1 trong ví dụ hoặc trong pha cuối cùng của thuật toán dạng ô nói chung. Thật không may, các truy cập có vấn đề có thể xảy ra trong tất cả các pha.


![[4.5.1.4.png]]
<p style="text-align:center;">Hình 4.5.1.4: Pha 0 tải cho khối (1, 1) </p>

Từ hình 4.5.1.4, chúng ta thấy rằng luồng (1,0) và luồng (1,1) cố gắng truy cập các phần tử M không tồn tại M3,0 và M3,1, trong khi luồng (0,1) và luồng (1,1) cố gắng truy cập N0,3 và N1,3, không tồn tại.

Điều này gợi ý rằng việc kiểm tra điều kiện biên cần xảy ra trong mọi pha của thuật toán dạng ô. Chỉ là các luồng khác nhau trong các khối luồng khác nhau có thể gặp tình huống điều kiện biên trong các pha này.

Lưu ý rằng các truy cập có vấn đề này không thể được ngăn chặn bằng cách loại trừ các luồng không tính toán các phần tử P hợp lệ. Ví dụ, luồng 1,0 trong khối 1,1 không tính toán bất kỳ phần tử P hợp lệ nào. Tuy nhiên, nó cần tải M2,1 trong pha 0. Hơn nữa, một số luồng tính toán các phần tử P hợp lệ sẽ cố gắng truy cập các phần tử M hoặc N không tồn tại. Như được hiển thị trong Hình 4.5.1.1, luồng 0,1 của khối 0,0 tính toán một phần tử P hợp lệ P0,1. Tuy nhiên, nó cố gắng truy cập M0,3 không tồn tại trong pha 1. Những quan sát này chỉ ra rằng các kiểm tra điều kiện biên khác nhau cần được thực hiện để tải gạch M, tải gạch N và tính toán/lưu trữ các phần tử P.
## Tóm tắt 2 trường hợp chính
Trường hợp đầu tiên là các luồng không tính toán các phần tử P hợp lệ, chúng vẫn cần tham gia tải các phần tử gạch đầu vào hợp lệ. Ví dụ, trong pha 0 của khối 11, luồng 10 được cho là tính toán P32 không tồn tại, vì vậy nó không tính toán bất kỳ phần tử P hợp lệ nào, nhưng nó vẫn cần tham gia tải phần tử gạch đầu vào n12.
Trường hợp thứ hai là các luồng tính toán các phần tử P hợp lệ có thể cố gắng tải các phần tử gạch đầu vào không tồn tại khi tải gạch đầu vào. Ví dụ, trong pha 0 của khối 00, luồng 10, được gán để tính toán P10 hợp lệ, có thể cố gắng tải N30 không tồn tại.

Điều này thực sự gợi ý rằng chúng ta cần có khả năng kiểm tra các điều kiện khác nhau cho mỗi luồng khi tải các phần tử gạch so với khi thực hiện tính toán tích vô hướng và ghi vào phần tử đầu ra. Và đây chính xác là những gì chúng ta sẽ làm trong thiết kế kernel của mình.
# Một giải pháp "đơn giản"

# Ví dụ và triển khai

# Tóm tắt các quan sát

# Mở rộng cho ma trận hình chữ nhật

# Kết luận