Phép nhân ma trận dạng ô kernel trình bày trong 4.4 chỉ có thể xử lí ma trận có kích thước là bội số của chiều rộng ô vuông
# Mục tiêu
Để xử lí ma trận có kích thước bất kì trong phép nhân ma trận dạng ô
- Kiểm tra điều kiện biên khi tải các ô
- Điều chỉnh nội dung của [[ô]] để đơn giản hóa phép tính lõi
- Mở rộng kĩ thuật để xử lí ma trận hình chữ nhật

# Vấn đề của với ma trận có kích thước không chia hết chiều rộng ô 
## Ví dụ 3 x 3


![[Screenshot 2025-03-04 113614.png]]
<p style="text-align:center;">Hình 4.5.1 Pha 1 tải cho khối (0, 0)</p>

Các ma trận có kích thước 3 x 3, không phải là bội số của chiều rộng ô (2)
Ô mặt 0 hoàn toàn nằm trong phạm vi hợp lệ của cả M và N

Khi chuyển sang pha 1, chúng ta thấy rằng để [[tải ô]] M, chúng ta sẽ cố gắng tải hai phần tử M không hợp lệ trong ví dụ này. Vì vậy, luồng (0, 1) và luồng (1, 1) trong trường hợp này cần được xử lý đặc biệt khi tải gạch M.

Mặc dù về mặt khái niệm, hai luồng này đang tải các phần tử M không hợp lệ hoặc không tồn tại, nhưng trên thực tế, do bố cục hàng chính, các luồng này sẽ tải không chính xác các phần tử tiếp theo, là M1,0 và M2,0 trong trường hợp này, vào vị trí bộ nhớ chia sẻ của chúng.

Các phần tử được tải không chính xác này sẽ gây ra kết quả tính toán không chính xác nếu chúng ta sử dụng chúng trong tính toán tích vô hướng cho các phần tử P đó.

Bây giờ chúng ta hãy [[chuyển]] sự chú ý đến việc tải ô N. Việc tải ô N trong [[pha]] này sẽ liên quan đến [[luồng|]] (1, 0) và [[luồng]] (1, 1) cố gắng tải các phần tử N không tồn tại.

Và điều này hơi khác so với trường hợp N vì các phần tử N không tồn tại đó sẽ hoàn toàn nằm ngoài phạm vi hợp lệ của dữ liệu N.

Vì vậy, trên hầu hết các phần cứng, điều này có thể gây ra vi phạm truy cập bộ nhớ vì chương trình đang cố gắng truy cập một vị trí không được cấp phát đúng cách. Điều đó có nghĩa là luồng 10 và luồng 11 cần được xử lý đặc biệt và chúng ta thực sự nên tránh thực hiện bất kỳ truy cập nào vào các vị trí đó.


Luồng (0,1) và luồng (1,1) sẽ cố gắng tải các phần tử M không tồn tại. Tương tự, luồng (1,0) và luồng (1,1) sẽ cố gắng truy cập các phần tử N không tồn tại.

Việc truy cập các phần tử không tồn tại có vấn đề theo hai cách. Việc truy cập một phần tử không tồn tại vượt quá cuối hàng (truy cập M bởi luồng 1,0 và luồng 1,1 trong Hình 4.18) sẽ được thực hiện đến các phần tử không chính xác. Trong ví dụ của chúng ta, các luồng sẽ cố gắng truy cập M0,3 và M1,3, cả hai đều không tồn tại. Trong trường hợp này, điều gì sẽ xảy ra với các tải bộ nhớ này? Để trả lời câu hỏi này, chúng ta cần quay lại bố cục tuyến tính hóa của ma trận 2D. Phần tử sau M0,2 trong bố cục tuyến tính hóa là M1,0. Mặc dù luồng 0,1 đang cố gắng truy cập M0,3, nó sẽ thay vào đó lấy M1,0. Việc sử dụng giá trị này trong tính toán tích vô hướng tiếp theo chắc chắn sẽ làm hỏng giá trị đầu ra.

Một vấn đề tương tự phát sinh khi truy cập một phần tử vượt quá cuối cột (truy cập N bởi luồng 1,0 và luồng 1,1 trong Hình 4.18). Các truy cập này là đến các vị trí bộ nhớ bên ngoài vùng được cấp phát cho mảng. Một số hệ thống sẽ trả về các giá trị ngẫu nhiên từ các cấu trúc dữ liệu khác, trong khi những hệ thống khác sẽ từ chối các truy cập này và khiến chương trình bị hủy. Dù bằng cách nào, các truy cập như vậy đều dẫn đến kết quả không mong muốn.

Từ thảo luận của chúng ta cho đến nay, các truy cập có vấn đề dường như chỉ phát sinh trong pha thực thi cuối cùng của các luồng. Quan sát này cho thấy rằng vấn đề có thể được giải quyết bằng cách thực hiện các hành động đặc biệt trong pha cuối cùng của việc thực thi kernel xếp gạch. Thật không may, các truy cập có vấn đề có thể xảy ra trong tất cả các pha. Hình 4.19 cho thấy mẫu truy cập bộ nhớ của khối 1,1 trong pha 0. Chúng ta thấy rằng luồng 1,0 và luồng 1,1 cố gắng truy cập các phần tử M không tồn tại M3,0 và M3,1, trong khi luồng 0,1 và luồng 1,1 cố gắng truy cập N0,3 và N1,3, không tồn tại.

Lưu ý rằng các truy cập có vấn đề này không thể được ngăn chặn bằng cách loại trừ các luồng không tính toán các phần tử P hợp lệ. Ví dụ, luồng 1,0 trong khối 1,1 không tính toán bất kỳ phần tử P hợp lệ nào. Tuy nhiên, nó cần tải M2,1 trong pha 0. Hơn nữa, một số luồng tính toán các phần tử P hợp lệ sẽ cố gắng truy cập các phần tử M hoặc N không tồn tại. Như được hiển thị trong Hình 4.18, luồng 0,1 của khối 0,0 tính toán một phần tử P hợp lệ P0,1. Tuy nhiên, nó cố gắng truy cập M0,3 không tồn tại trong pha 1. Những quan sát này chỉ ra rằng các kiểm tra điều kiện biên khác nhau cần được thực hiện để tải gạch M, tải gạch N và tính toán/lưu trữ các phần tử P.
## 2 trường hợp chính trong ví dụ trò chơi
# Một giải pháp "đơn giản"

# Ví dụ và triển khai

# Tóm tắt các quan sát

# Mở rộng cho ma trận hình chữ nhật

# Kết luận